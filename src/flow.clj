(ns flow)

(defn -main []
  (println (str "2 is " (if (even? 2) "even" "odd")))
  (println (if (true? false) "impossible!"))
  (println (if true :truthy :falsey))
  (println (if (Object.) :truthy :falsey))
  (println (if [] :truthy :falsey))
  (println (if 0 :truthy :falsey))
  (println (if false :truthy :falsey))
  (println (if nil :truthy :falsey))
  (println (if (even? 5) (do (println "even") true) (do (println "odd") false)))
  (println (let [x 1] (when (neg? x) (throw (RuntimeException. (str "x must be positive: " x))))))
  (println (let [x 5] (cond (< x 2) "x is less than 2" (< x 10) "x is less than 10")))
  (println (let [x 11] (cond (< x 2) "x is less than 2" (< x 10) "x is less than 10" :else "x is greater than or equal to 10")))
  (defn foo [x] (case x 5 "x is 5" 10 "x is 10"))
  (println (foo 10))
  (defn foo2 [x] (case x 5 "x is 5" 10 "x is 10" "x is not 5 or 10"))
  (println (foo2 11))
  (dotimes [i 3] (println i))
  (doseq [n (range 3)] (println n))
  (doseq [letter [:a :b] number (range 3)]  (prn letter number))
  (println (for [letter [:a :b] number (range 3)] [letter number]))
  (println (loop [i 0] (if (< i 10) (recur (inc i)) i)))
  (defn increase [i] (if (< i 10) (recur (inc i)) i))
  (println (increase 0))
  (println)
  (try (/ 2 1) (catch ArithmeticException e "divide by zero") (finally (println "cleanup")))
  (println (try (throw (Exception. "something went wrong...")) (catch Exception e (.getMessage e))))
  (try (throw (ex-info "There was a problem" {:detail 42}))
       (catch Exception e (prn (:detail (ex-data e)))))
  (let [f (clojure.java.io/writer "/tmp/new")]
    (try (.write f "some text")
         (finally (.close f))))
  (with-open [f (clojure.java.io/writer  "/tmp/new")] (.write f "some text!"))
  (println))
